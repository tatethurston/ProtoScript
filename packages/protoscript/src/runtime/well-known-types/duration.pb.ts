// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/duration.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * A Duration represents a signed, fixed-length span of time represented
 * as a count of seconds and fractions of seconds at nanosecond
 * resolution. It is independent of any calendar and concepts like "day"
 * or "month". It is related to Timestamp in that the difference between
 * two Timestamp values is a Duration and it can be added or subtracted
 * from a Timestamp. Range is approximately +-10,000 years.
 *
 * # Examples
 *
 * Example 1: Compute Duration from two Timestamps in pseudo code.
 *
 *     Timestamp start = ...;
 *     Timestamp end = ...;
 *     Duration duration = ...;
 *
 *     duration.seconds = end.seconds - start.seconds;
 *     duration.nanos = end.nanos - start.nanos;
 *
 *     if (duration.seconds < 0 && duration.nanos > 0) {
 *       duration.seconds += 1;
 *       duration.nanos -= 1000000000;
 *     } else if (duration.seconds > 0 && duration.nanos < 0) {
 *       duration.seconds -= 1;
 *       duration.nanos += 1000000000;
 *     }
 *
 * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
 *
 *     Timestamp start = ...;
 *     Duration duration = ...;
 *     Timestamp end = ...;
 *
 *     end.seconds = start.seconds + duration.seconds;
 *     end.nanos = start.nanos + duration.nanos;
 *
 *     if (end.nanos < 0) {
 *       end.seconds -= 1;
 *       end.nanos += 1000000000;
 *     } else if (end.nanos >= 1000000000) {
 *       end.seconds += 1;
 *       end.nanos -= 1000000000;
 *     }
 *
 * Example 3: Compute Duration from datetime.timedelta in Python.
 *
 *     td = datetime.timedelta(days=3, minutes=10)
 *     duration = Duration()
 *     duration.FromTimedelta(td)
 *
 * # JSON Mapping
 *
 * In JSON format, the Duration type is encoded as a string rather than an
 * object, where the string ends in the suffix "s" (indicating seconds) and
 * is preceded by the number of seconds, with nanoseconds expressed as
 * fractional seconds. For example, 3 seconds with 0 nanoseconds should be
 * encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
 * be expressed in JSON format as "3.000000001s", and 3 seconds and 1
 * microsecond should be expressed in JSON format as "3.000001s".
 *
 */
export interface Duration {
  /**
   * Signed seconds of the span of time. Must be from -315,576,000,000
   * to +315,576,000,000 inclusive. Note: these bounds are computed from:
   * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
   */
  seconds: bigint;
  /**
   * Signed fractions of a second at nanosecond resolution of the span
   * of time. Durations less than one second are represented with a 0
   * `seconds` field and a positive or negative `nanos` field. For durations
   * of one second or more, a non-zero value for the `nanos` field must be
   * of the same sign as the `seconds` field. Must be from -999,999,999
   * to +999,999,999 inclusive.
   */
  nanos: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Duration = {
  /**
   * Serializes Duration to protobuf.
   */
  encode: function (msg: PartialDeep<Duration>): Uint8Array {
    return Duration._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Duration from protobuf.
   */
  decode: function (bytes: ByteSource): Duration {
    return Duration._readMessage(
      Duration.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Duration with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Duration>): Duration {
    return {
      seconds: 0n,
      nanos: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Duration>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString() as any);
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Duration,
    reader: protoscript.BinaryReader,
  ): Duration {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const DurationJSON = {
  /**
   * Serializes Duration to JSON.
   */
  encode: function (msg: PartialDeep<Duration>): string {
    return JSON.stringify(DurationJSON._writeMessage(msg));
  },

  /**
   * Deserializes Duration from JSON.
   */
  decode: function (json: string): Duration {
    return DurationJSON._readMessage(
      DurationJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Duration with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Duration>): Duration {
    return {
      seconds: 0n,
      nanos: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Duration>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.seconds) {
      json["seconds"] = String(msg.seconds);
    }
    if (msg.nanos) {
      json["nanos"] = msg.nanos;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Duration, json: any): Duration {
    const _seconds_ = json["seconds"];
    if (_seconds_) {
      msg.seconds = BigInt(_seconds_);
    }
    const _nanos_ = json["nanos"];
    if (_nanos_) {
      msg.nanos = protoscript.parseNumber(_nanos_);
    }
    return msg;
  },
};
