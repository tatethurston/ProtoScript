// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/type.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

import { SourceContext, SourceContextJSON } from "./source_context.pb";
import { Any, AnyJSON } from "./any.pb";

//========================================//
//                 Types                  //
//========================================//

/**
 * The syntax in which a protocol buffer element is defined.
 */
export type Syntax = "SYNTAX_PROTO2" | "SYNTAX_PROTO3";

/**
 * A protocol buffer message type.
 */
export interface Type {
  /**
   * The fully qualified message name.
   */
  name: string;
  /**
   * The list of fields.
   */
  fields: Field[];
  /**
   * The list of types appearing in `oneof` definitions in this type.
   */
  oneofs: string[];
  /**
   * The protocol buffer options.
   */
  options: Option[];
  /**
   * The source context.
   */
  sourceContext: SourceContext;
  /**
   * The source syntax.
   */
  syntax: Syntax;
}

/**
 * A single field of a message type.
 */
export interface Field {
  /**
   * The field type.
   */
  kind: Field.Kind;
  /**
   * The field cardinality.
   */
  cardinality: Field.Cardinality;
  /**
   * The field number.
   */
  number: number;
  /**
   * The field name.
   */
  name: string;
  /**
   * The field type URL, without the scheme, for message or enumeration
   * types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`.
   */
  typeUrl: string;
  /**
   * The index of the field type in `Type.oneofs`, for message or enumeration
   * types. The first type has index 1; zero means the type is not in the list.
   */
  oneofIndex: number;
  /**
   * Whether to use alternative packed wire representation.
   */
  packed: boolean;
  /**
   * The protocol buffer options.
   */
  options: Option[];
  /**
   * The field JSON name.
   */
  jsonName: string;
  /**
   * The string value of the default value of this field. Proto2 syntax only.
   */
  defaultValue: string;
}

export declare namespace Field {
  /**
   * Basic field types.
   */
  export type Kind =
    | "TYPE_UNKNOWN"
    | "TYPE_DOUBLE"
    | "TYPE_FLOAT"
    | "TYPE_INT64"
    | "TYPE_UINT64"
    | "TYPE_INT32"
    | "TYPE_FIXED64"
    | "TYPE_FIXED32"
    | "TYPE_BOOL"
    | "TYPE_STRING"
    | "TYPE_GROUP"
    | "TYPE_MESSAGE"
    | "TYPE_BYTES"
    | "TYPE_UINT32"
    | "TYPE_ENUM"
    | "TYPE_SFIXED32"
    | "TYPE_SFIXED64"
    | "TYPE_SINT32"
    | "TYPE_SINT64";

  /**
   * Whether a field is optional, required, or repeated.
   */
  export type Cardinality =
    | "CARDINALITY_UNKNOWN"
    | "CARDINALITY_OPTIONAL"
    | "CARDINALITY_REQUIRED"
    | "CARDINALITY_REPEATED";
}

/**
 * Enum type definition.
 */
export interface Enum {
  /**
   * Enum type name.
   */
  name: string;
  /**
   * Enum value definitions.
   */
  enumvalue: EnumValue[];
  /**
   * Protocol buffer options.
   */
  options: Option[];
  /**
   * The source context.
   */
  sourceContext: SourceContext;
  /**
   * The source syntax.
   */
  syntax: Syntax;
}

/**
 * Enum value definition.
 */
export interface EnumValue {
  /**
   * Enum value name.
   */
  name: string;
  /**
   * Enum value number.
   */
  number: number;
  /**
   * Protocol buffer options.
   */
  options: Option[];
}

/**
 * A protocol buffer option, which can be attached to a message, field,
 * enumeration, etc.
 */
export interface Option {
  /**
   * The option's name. For protobuf built-in options (options defined in
   * descriptor.proto), this is the short name. For example, `"map_entry"`.
   * For custom options, it should be the fully-qualified name. For example,
   * `"google.api.http"`.
   */
  name: string;
  /**
   * The option's value packed in an Any message. If the value is a primitive,
   * the corresponding wrapper type defined in google/protobuf/wrappers.proto
   * should be used. If the value is an enum, it should be stored as an int32
   * value using the google.protobuf.Int32Value type.
   */
  value: Any;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Syntax = {
  /**
   * Syntax `proto2`.
   */
  SYNTAX_PROTO2: "SYNTAX_PROTO2",
  /**
   * Syntax `proto3`.
   */
  SYNTAX_PROTO3: "SYNTAX_PROTO3",
  /**
   * @private
   */
  _fromInt: function (i: number): Syntax {
    switch (i) {
      case 0: {
        return "SYNTAX_PROTO2";
      }
      case 1: {
        return "SYNTAX_PROTO3";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Syntax;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Syntax): number {
    switch (i) {
      case "SYNTAX_PROTO2": {
        return 0;
      }
      case "SYNTAX_PROTO3": {
        return 1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const Type = {
  /**
   * Serializes Type to protobuf.
   */
  encode: function (msg: Partial<Type>): Uint8Array {
    return Type._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Type from protobuf.
   */
  decode: function (bytes: ByteSource): Type {
    return Type._readMessage(Type.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Type with all fields set to their default value.
   */
  initialize: function (): Type {
    return {
      name: "",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: Syntax._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Type>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.fields?.length) {
      writer.writeRepeatedMessage(2, msg.fields as any, Field._writeMessage);
    }
    if (msg.oneofs?.length) {
      writer.writeRepeatedString(3, msg.oneofs);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(4, msg.options as any, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && Syntax._toInt(msg.syntax)) {
      writer.writeEnum(6, Syntax._toInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Type, reader: BinaryReader): Type {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Field.initialize();
          reader.readMessage(m, Field._readMessage);
          msg.fields.push(m);
          break;
        }
        case 3: {
          msg.oneofs.push(reader.readString());
          break;
        }
        case 4: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          msg.syntax = Syntax._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Field = {
  /**
   * Serializes Field to protobuf.
   */
  encode: function (msg: Partial<Field>): Uint8Array {
    return Field._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Field from protobuf.
   */
  decode: function (bytes: ByteSource): Field {
    return Field._readMessage(Field.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Field with all fields set to their default value.
   */
  initialize: function (): Field {
    return {
      kind: Field.Kind._fromInt(0),
      cardinality: Field.Cardinality._fromInt(0),
      number: 0,
      name: "",
      typeUrl: "",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: "",
      defaultValue: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Field>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.kind && Field.Kind._toInt(msg.kind)) {
      writer.writeEnum(1, Field.Kind._toInt(msg.kind));
    }
    if (msg.cardinality && Field.Cardinality._toInt(msg.cardinality)) {
      writer.writeEnum(2, Field.Cardinality._toInt(msg.cardinality));
    }
    if (msg.number) {
      writer.writeInt32(3, msg.number);
    }
    if (msg.name) {
      writer.writeString(4, msg.name);
    }
    if (msg.typeUrl) {
      writer.writeString(6, msg.typeUrl);
    }
    if (msg.oneofIndex) {
      writer.writeInt32(7, msg.oneofIndex);
    }
    if (msg.packed) {
      writer.writeBool(8, msg.packed);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(9, msg.options as any, Option._writeMessage);
    }
    if (msg.jsonName) {
      writer.writeString(10, msg.jsonName);
    }
    if (msg.defaultValue) {
      writer.writeString(11, msg.defaultValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Field, reader: BinaryReader): Field {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.kind = Field.Kind._fromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.cardinality = Field.Cardinality._fromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.number = reader.readInt32();
          break;
        }
        case 4: {
          msg.name = reader.readString();
          break;
        }
        case 6: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 7: {
          msg.oneofIndex = reader.readInt32();
          break;
        }
        case 8: {
          msg.packed = reader.readBool();
          break;
        }
        case 9: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 10: {
          msg.jsonName = reader.readString();
          break;
        }
        case 11: {
          msg.defaultValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Kind: {
    /**
     * Field type unknown.
     */
    TYPE_UNKNOWN: "TYPE_UNKNOWN",
    /**
     * Field type double.
     */
    TYPE_DOUBLE: "TYPE_DOUBLE",
    /**
     * Field type float.
     */
    TYPE_FLOAT: "TYPE_FLOAT",
    /**
     * Field type int64.
     */
    TYPE_INT64: "TYPE_INT64",
    /**
     * Field type uint64.
     */
    TYPE_UINT64: "TYPE_UINT64",
    /**
     * Field type int32.
     */
    TYPE_INT32: "TYPE_INT32",
    /**
     * Field type fixed64.
     */
    TYPE_FIXED64: "TYPE_FIXED64",
    /**
     * Field type fixed32.
     */
    TYPE_FIXED32: "TYPE_FIXED32",
    /**
     * Field type bool.
     */
    TYPE_BOOL: "TYPE_BOOL",
    /**
     * Field type string.
     */
    TYPE_STRING: "TYPE_STRING",
    /**
     * Field type group. Proto2 syntax only, and deprecated.
     */
    TYPE_GROUP: "TYPE_GROUP",
    /**
     * Field type message.
     */
    TYPE_MESSAGE: "TYPE_MESSAGE",
    /**
     * Field type bytes.
     */
    TYPE_BYTES: "TYPE_BYTES",
    /**
     * Field type uint32.
     */
    TYPE_UINT32: "TYPE_UINT32",
    /**
     * Field type enum.
     */
    TYPE_ENUM: "TYPE_ENUM",
    /**
     * Field type sfixed32.
     */
    TYPE_SFIXED32: "TYPE_SFIXED32",
    /**
     * Field type sfixed64.
     */
    TYPE_SFIXED64: "TYPE_SFIXED64",
    /**
     * Field type sint32.
     */
    TYPE_SINT32: "TYPE_SINT32",
    /**
     * Field type sint64.
     */
    TYPE_SINT64: "TYPE_SINT64",
    /**
     * @private
     */
    _fromInt: function (i: number): Field.Kind {
      switch (i) {
        case 0: {
          return "TYPE_UNKNOWN";
        }
        case 1: {
          return "TYPE_DOUBLE";
        }
        case 2: {
          return "TYPE_FLOAT";
        }
        case 3: {
          return "TYPE_INT64";
        }
        case 4: {
          return "TYPE_UINT64";
        }
        case 5: {
          return "TYPE_INT32";
        }
        case 6: {
          return "TYPE_FIXED64";
        }
        case 7: {
          return "TYPE_FIXED32";
        }
        case 8: {
          return "TYPE_BOOL";
        }
        case 9: {
          return "TYPE_STRING";
        }
        case 10: {
          return "TYPE_GROUP";
        }
        case 11: {
          return "TYPE_MESSAGE";
        }
        case 12: {
          return "TYPE_BYTES";
        }
        case 13: {
          return "TYPE_UINT32";
        }
        case 14: {
          return "TYPE_ENUM";
        }
        case 15: {
          return "TYPE_SFIXED32";
        }
        case 16: {
          return "TYPE_SFIXED64";
        }
        case 17: {
          return "TYPE_SINT32";
        }
        case 18: {
          return "TYPE_SINT64";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Field.Kind;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Field.Kind): number {
      switch (i) {
        case "TYPE_UNKNOWN": {
          return 0;
        }
        case "TYPE_DOUBLE": {
          return 1;
        }
        case "TYPE_FLOAT": {
          return 2;
        }
        case "TYPE_INT64": {
          return 3;
        }
        case "TYPE_UINT64": {
          return 4;
        }
        case "TYPE_INT32": {
          return 5;
        }
        case "TYPE_FIXED64": {
          return 6;
        }
        case "TYPE_FIXED32": {
          return 7;
        }
        case "TYPE_BOOL": {
          return 8;
        }
        case "TYPE_STRING": {
          return 9;
        }
        case "TYPE_GROUP": {
          return 10;
        }
        case "TYPE_MESSAGE": {
          return 11;
        }
        case "TYPE_BYTES": {
          return 12;
        }
        case "TYPE_UINT32": {
          return 13;
        }
        case "TYPE_ENUM": {
          return 14;
        }
        case "TYPE_SFIXED32": {
          return 15;
        }
        case "TYPE_SFIXED64": {
          return 16;
        }
        case "TYPE_SINT32": {
          return 17;
        }
        case "TYPE_SINT64": {
          return 18;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Cardinality: {
    /**
     * For fields with unknown cardinality.
     */
    CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN",
    /**
     * For optional fields.
     */
    CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL",
    /**
     * For required fields. Proto2 syntax only.
     */
    CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED",
    /**
     * For repeated fields.
     */
    CARDINALITY_REPEATED: "CARDINALITY_REPEATED",
    /**
     * @private
     */
    _fromInt: function (i: number): Field.Cardinality {
      switch (i) {
        case 0: {
          return "CARDINALITY_UNKNOWN";
        }
        case 1: {
          return "CARDINALITY_OPTIONAL";
        }
        case 2: {
          return "CARDINALITY_REQUIRED";
        }
        case 3: {
          return "CARDINALITY_REPEATED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Field.Cardinality;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Field.Cardinality): number {
      switch (i) {
        case "CARDINALITY_UNKNOWN": {
          return 0;
        }
        case "CARDINALITY_OPTIONAL": {
          return 1;
        }
        case "CARDINALITY_REQUIRED": {
          return 2;
        }
        case "CARDINALITY_REPEATED": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const Enum = {
  /**
   * Serializes Enum to protobuf.
   */
  encode: function (msg: Partial<Enum>): Uint8Array {
    return Enum._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Enum from protobuf.
   */
  decode: function (bytes: ByteSource): Enum {
    return Enum._readMessage(Enum.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Enum with all fields set to their default value.
   */
  initialize: function (): Enum {
    return {
      name: "",
      enumvalue: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: Syntax._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Enum>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.enumvalue?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.enumvalue as any,
        EnumValue._writeMessage
      );
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options as any, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(4, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && Syntax._toInt(msg.syntax)) {
      writer.writeEnum(5, Syntax._toInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Enum, reader: BinaryReader): Enum {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = EnumValue.initialize();
          reader.readMessage(m, EnumValue._readMessage);
          msg.enumvalue.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 5: {
          msg.syntax = Syntax._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EnumValue = {
  /**
   * Serializes EnumValue to protobuf.
   */
  encode: function (msg: Partial<EnumValue>): Uint8Array {
    return EnumValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes EnumValue from protobuf.
   */
  decode: function (bytes: ByteSource): EnumValue {
    return EnumValue._readMessage(
      EnumValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes EnumValue with all fields set to their default value.
   */
  initialize: function (): EnumValue {
    return {
      name: "",
      number: 0,
      options: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<EnumValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.number) {
      writer.writeInt32(2, msg.number);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options as any, Option._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: EnumValue, reader: BinaryReader): EnumValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.number = reader.readInt32();
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Option = {
  /**
   * Serializes Option to protobuf.
   */
  encode: function (msg: Partial<Option>): Uint8Array {
    return Option._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Option from protobuf.
   */
  decode: function (bytes: ByteSource): Option {
    return Option._readMessage(Option.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Option with all fields set to their default value.
   */
  initialize: function (): Option {
    return {
      name: "",
      value: Any.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Option>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.value) {
      writer.writeMessage(2, msg.value, Any._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Option, reader: BinaryReader): Option {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.value, Any._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const SyntaxJSON = {
  /**
   * Syntax `proto2`.
   */
  SYNTAX_PROTO2: "SYNTAX_PROTO2",
  /**
   * Syntax `proto3`.
   */
  SYNTAX_PROTO3: "SYNTAX_PROTO3",
  /**
   * @private
   */
  _fromInt: function (i: number): Syntax {
    switch (i) {
      case 0: {
        return "SYNTAX_PROTO2";
      }
      case 1: {
        return "SYNTAX_PROTO3";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Syntax;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: Syntax): number {
    switch (i) {
      case "SYNTAX_PROTO2": {
        return 0;
      }
      case "SYNTAX_PROTO3": {
        return 1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TypeJSON = {
  /**
   * Serializes Type to JSON.
   */
  encode: function (msg: Partial<Type>): string {
    return JSON.stringify(TypeJSON._writeMessage(msg));
  },

  /**
   * Deserializes Type from JSON.
   */
  decode: function (json: string): Type {
    return TypeJSON._readMessage(TypeJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Type with all fields set to their default value.
   */
  initialize: function (): Type {
    return {
      name: "",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: Syntax._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Type>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.fields?.length) {
      json["fields"] = msg.fields.map(FieldJSON._writeMessage);
    }
    if (msg.oneofs?.length) {
      json["oneofs"] = msg.oneofs;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON._writeMessage);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContextJSON._writeMessage(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json["sourceContext"] = sourceContext;
      }
    }
    if (msg.syntax && SyntaxJSON._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Type, json: any): Type {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _fields = json["fields"];
    if (_fields) {
      for (const item of _fields) {
        const m = Field.initialize();
        FieldJSON._readMessage(m, item);
        msg.fields.push(m);
      }
    }
    const _oneofs = json["oneofs"];
    if (_oneofs) {
      msg.oneofs = _oneofs;
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        OptionJSON._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json["sourceContext"] ?? json["source_context"];
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContextJSON._readMessage(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json["syntax"];
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const FieldJSON = {
  /**
   * Serializes Field to JSON.
   */
  encode: function (msg: Partial<Field>): string {
    return JSON.stringify(FieldJSON._writeMessage(msg));
  },

  /**
   * Deserializes Field from JSON.
   */
  decode: function (json: string): Field {
    return FieldJSON._readMessage(FieldJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Field with all fields set to their default value.
   */
  initialize: function (): Field {
    return {
      kind: Field.Kind._fromInt(0),
      cardinality: Field.Cardinality._fromInt(0),
      number: 0,
      name: "",
      typeUrl: "",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: "",
      defaultValue: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Field>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.kind && FieldJSON.Kind._toInt(msg.kind)) {
      json["kind"] = msg.kind;
    }
    if (msg.cardinality && FieldJSON.Cardinality._toInt(msg.cardinality)) {
      json["cardinality"] = msg.cardinality;
    }
    if (msg.number) {
      json["number"] = msg.number;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.typeUrl) {
      json["typeUrl"] = msg.typeUrl;
    }
    if (msg.oneofIndex) {
      json["oneofIndex"] = msg.oneofIndex;
    }
    if (msg.packed) {
      json["packed"] = msg.packed;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON._writeMessage);
    }
    if (msg.jsonName) {
      json["jsonName"] = msg.jsonName;
    }
    if (msg.defaultValue) {
      json["defaultValue"] = msg.defaultValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Field, json: any): Field {
    const _kind = json["kind"];
    if (_kind) {
      msg.kind = _kind;
    }
    const _cardinality = json["cardinality"];
    if (_cardinality) {
      msg.cardinality = _cardinality;
    }
    const _number = json["number"];
    if (_number) {
      msg.number = _number;
    }
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _typeUrl = json["typeUrl"] ?? json["type_url"];
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _oneofIndex = json["oneofIndex"] ?? json["oneof_index"];
    if (_oneofIndex) {
      msg.oneofIndex = _oneofIndex;
    }
    const _packed = json["packed"];
    if (_packed) {
      msg.packed = _packed;
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        OptionJSON._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _jsonName = json["jsonName"] ?? json["json_name"];
    if (_jsonName) {
      msg.jsonName = _jsonName;
    }
    const _defaultValue = json["defaultValue"] ?? json["default_value"];
    if (_defaultValue) {
      msg.defaultValue = _defaultValue;
    }
    return msg;
  },

  Kind: {
    /**
     * Field type unknown.
     */
    TYPE_UNKNOWN: "TYPE_UNKNOWN",
    /**
     * Field type double.
     */
    TYPE_DOUBLE: "TYPE_DOUBLE",
    /**
     * Field type float.
     */
    TYPE_FLOAT: "TYPE_FLOAT",
    /**
     * Field type int64.
     */
    TYPE_INT64: "TYPE_INT64",
    /**
     * Field type uint64.
     */
    TYPE_UINT64: "TYPE_UINT64",
    /**
     * Field type int32.
     */
    TYPE_INT32: "TYPE_INT32",
    /**
     * Field type fixed64.
     */
    TYPE_FIXED64: "TYPE_FIXED64",
    /**
     * Field type fixed32.
     */
    TYPE_FIXED32: "TYPE_FIXED32",
    /**
     * Field type bool.
     */
    TYPE_BOOL: "TYPE_BOOL",
    /**
     * Field type string.
     */
    TYPE_STRING: "TYPE_STRING",
    /**
     * Field type group. Proto2 syntax only, and deprecated.
     */
    TYPE_GROUP: "TYPE_GROUP",
    /**
     * Field type message.
     */
    TYPE_MESSAGE: "TYPE_MESSAGE",
    /**
     * Field type bytes.
     */
    TYPE_BYTES: "TYPE_BYTES",
    /**
     * Field type uint32.
     */
    TYPE_UINT32: "TYPE_UINT32",
    /**
     * Field type enum.
     */
    TYPE_ENUM: "TYPE_ENUM",
    /**
     * Field type sfixed32.
     */
    TYPE_SFIXED32: "TYPE_SFIXED32",
    /**
     * Field type sfixed64.
     */
    TYPE_SFIXED64: "TYPE_SFIXED64",
    /**
     * Field type sint32.
     */
    TYPE_SINT32: "TYPE_SINT32",
    /**
     * Field type sint64.
     */
    TYPE_SINT64: "TYPE_SINT64",
    /**
     * @private
     */
    _fromInt: function (i: number): Field.Kind {
      switch (i) {
        case 0: {
          return "TYPE_UNKNOWN";
        }
        case 1: {
          return "TYPE_DOUBLE";
        }
        case 2: {
          return "TYPE_FLOAT";
        }
        case 3: {
          return "TYPE_INT64";
        }
        case 4: {
          return "TYPE_UINT64";
        }
        case 5: {
          return "TYPE_INT32";
        }
        case 6: {
          return "TYPE_FIXED64";
        }
        case 7: {
          return "TYPE_FIXED32";
        }
        case 8: {
          return "TYPE_BOOL";
        }
        case 9: {
          return "TYPE_STRING";
        }
        case 10: {
          return "TYPE_GROUP";
        }
        case 11: {
          return "TYPE_MESSAGE";
        }
        case 12: {
          return "TYPE_BYTES";
        }
        case 13: {
          return "TYPE_UINT32";
        }
        case 14: {
          return "TYPE_ENUM";
        }
        case 15: {
          return "TYPE_SFIXED32";
        }
        case 16: {
          return "TYPE_SFIXED64";
        }
        case 17: {
          return "TYPE_SINT32";
        }
        case 18: {
          return "TYPE_SINT64";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Field.Kind;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Field.Kind): number {
      switch (i) {
        case "TYPE_UNKNOWN": {
          return 0;
        }
        case "TYPE_DOUBLE": {
          return 1;
        }
        case "TYPE_FLOAT": {
          return 2;
        }
        case "TYPE_INT64": {
          return 3;
        }
        case "TYPE_UINT64": {
          return 4;
        }
        case "TYPE_INT32": {
          return 5;
        }
        case "TYPE_FIXED64": {
          return 6;
        }
        case "TYPE_FIXED32": {
          return 7;
        }
        case "TYPE_BOOL": {
          return 8;
        }
        case "TYPE_STRING": {
          return 9;
        }
        case "TYPE_GROUP": {
          return 10;
        }
        case "TYPE_MESSAGE": {
          return 11;
        }
        case "TYPE_BYTES": {
          return 12;
        }
        case "TYPE_UINT32": {
          return 13;
        }
        case "TYPE_ENUM": {
          return 14;
        }
        case "TYPE_SFIXED32": {
          return 15;
        }
        case "TYPE_SFIXED64": {
          return 16;
        }
        case "TYPE_SINT32": {
          return 17;
        }
        case "TYPE_SINT64": {
          return 18;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  Cardinality: {
    /**
     * For fields with unknown cardinality.
     */
    CARDINALITY_UNKNOWN: "CARDINALITY_UNKNOWN",
    /**
     * For optional fields.
     */
    CARDINALITY_OPTIONAL: "CARDINALITY_OPTIONAL",
    /**
     * For required fields. Proto2 syntax only.
     */
    CARDINALITY_REQUIRED: "CARDINALITY_REQUIRED",
    /**
     * For repeated fields.
     */
    CARDINALITY_REPEATED: "CARDINALITY_REPEATED",
    /**
     * @private
     */
    _fromInt: function (i: number): Field.Cardinality {
      switch (i) {
        case 0: {
          return "CARDINALITY_UNKNOWN";
        }
        case 1: {
          return "CARDINALITY_OPTIONAL";
        }
        case 2: {
          return "CARDINALITY_REQUIRED";
        }
        case 3: {
          return "CARDINALITY_REPEATED";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as Field.Cardinality;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: Field.Cardinality): number {
      switch (i) {
        case "CARDINALITY_UNKNOWN": {
          return 0;
        }
        case "CARDINALITY_OPTIONAL": {
          return 1;
        }
        case "CARDINALITY_REQUIRED": {
          return 2;
        }
        case "CARDINALITY_REPEATED": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

export const EnumJSON = {
  /**
   * Serializes Enum to JSON.
   */
  encode: function (msg: Partial<Enum>): string {
    return JSON.stringify(EnumJSON._writeMessage(msg));
  },

  /**
   * Deserializes Enum from JSON.
   */
  decode: function (json: string): Enum {
    return EnumJSON._readMessage(EnumJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Enum with all fields set to their default value.
   */
  initialize: function (): Enum {
    return {
      name: "",
      enumvalue: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: Syntax._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Enum>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.enumvalue?.length) {
      json["enumvalue"] = msg.enumvalue.map(EnumValueJSON._writeMessage);
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON._writeMessage);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContextJSON._writeMessage(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json["sourceContext"] = sourceContext;
      }
    }
    if (msg.syntax && SyntaxJSON._toInt(msg.syntax)) {
      json["syntax"] = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Enum, json: any): Enum {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _enumvalue = json["enumvalue"];
    if (_enumvalue) {
      for (const item of _enumvalue) {
        const m = EnumValue.initialize();
        EnumValueJSON._readMessage(m, item);
        msg.enumvalue.push(m);
      }
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        OptionJSON._readMessage(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json["sourceContext"] ?? json["source_context"];
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContextJSON._readMessage(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json["syntax"];
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const EnumValueJSON = {
  /**
   * Serializes EnumValue to JSON.
   */
  encode: function (msg: Partial<EnumValue>): string {
    return JSON.stringify(EnumValueJSON._writeMessage(msg));
  },

  /**
   * Deserializes EnumValue from JSON.
   */
  decode: function (json: string): EnumValue {
    return EnumValueJSON._readMessage(
      EnumValueJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes EnumValue with all fields set to their default value.
   */
  initialize: function (): EnumValue {
    return {
      name: "",
      number: 0,
      options: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<EnumValue>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.number) {
      json["number"] = msg.number;
    }
    if (msg.options?.length) {
      json["options"] = msg.options.map(OptionJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: EnumValue, json: any): EnumValue {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _number = json["number"];
    if (_number) {
      msg.number = _number;
    }
    const _options = json["options"];
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        OptionJSON._readMessage(m, item);
        msg.options.push(m);
      }
    }
    return msg;
  },
};

export const OptionJSON = {
  /**
   * Serializes Option to JSON.
   */
  encode: function (msg: Partial<Option>): string {
    return JSON.stringify(OptionJSON._writeMessage(msg));
  },

  /**
   * Deserializes Option from JSON.
   */
  decode: function (json: string): Option {
    return OptionJSON._readMessage(OptionJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Option with all fields set to their default value.
   */
  initialize: function (): Option {
    return {
      name: "",
      value: Any.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Option>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.value) {
      const value = AnyJSON._writeMessage(msg.value);
      if (Object.keys(value).length > 0) {
        json["value"] = value;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Option, json: any): Option {
    const _name = json["name"];
    if (_name) {
      msg.name = _name;
    }
    const _value = json["value"];
    if (_value) {
      const m = Any.initialize();
      AnyJSON._readMessage(m, _value);
      msg.value = m;
    }
    return msg;
  },
};
